
单例模式  

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。  

注意：
1、单例类只能有一个实例。    
2、单例类必须自己创建自己的唯一实例。    
3、单例类必须给所有其他对象提供这一实例。    

介绍
意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。  

主要解决：一个全局使用的类频繁地创建与销毁。  

何时使用：当您想控制实例数目，节省系统资源的时候。    

如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。    

关键代码：构造函数是私有的;唯一的个体为静态成员变量；使用Pthread_once来创建唯一个体；      

应用实例：
1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。  
2、避免对资源的多重占用（比如写文件操作）。  
缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。  

使用场景：  
1、要求生产唯一序列号。  
2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。  
3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。  

```c++

template<typename T>
pthread_once_t Singleton<T>::ponce_=PTHREAD_ONCE_INIT;

template<typename T>
T *Singleton<T>::value_=NULL;

template <typename T>
class Singleton : boost::noncopyable
{
  public:

  static T& create()
  {
      pthread_once(&ponce_,&Singleton::init);
      return *value_; 
  }
  
  private:
  
  Singleton();
  ~Singleton();
  
  static init()
  {
      value_=new T();
  }
  
  static pthread_once_t ponce_;
  static T* value_;
  
}
```
